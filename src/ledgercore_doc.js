// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni

/**Class representing a Tezos transaction */
declare class NJSTezosLikeTransaction
{
    /** Get type of operation (transaction, reveal ... cf TezosOperationTag) */
    declare function getType(): TezosOperationTag;
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get Fees (in drop) */
    declare function getFees(): NJSAmount;
    /** Get destination XTZ. address */
    declare function getReceiver(): ?NJSTezosLikeAddress;
    /** Get XTZ. sender address */
    declare function getSender(): NJSTezosLikeAddress;
    /** Get amount of XTZ to send */
    declare function getValue(): ?NJSAmount;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Set signature of transaction, when a signature is set serialize method gives back serialized Tx */
    declare function setSignature(signature: Object);
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction
     */
    declare function getDate(): Date;
    /** Get Signing public Key */
    declare function getSigningPubKey(): Object;
    declare function getCounter(): NJSBigInt;
    declare function getGasLimit(): NJSAmount;
    declare function getStorageLimit(): NJSBigInt;
    /** Get hash of block in which tx is included */
    declare function getBlockHash(): ?string;
    /** Get status of transaction: equals to 1 if succeeded, 0 otherwise */
    declare function getStatus(): number;
}
/**Class representing a Tezos Operation */
declare class NJSTezosLikeOperation
{
    /**
     *Get operation's transaction
     *@return TezosLikeTransaction object
     */
    declare function getTransaction(): NJSTezosLikeTransaction;
}
/**Class representing Bitcoin block */
declare class NJSTezosLikeBlock
{
    /**
     *Hash of block
     *@return string representing hash of this block
     */
    declare function getHash(): string;
    /**
     *Height of block in blockchain
     *@return 64 bits integer, height of block
     */
    declare function getHeight(): number;
    /**
     *Timestamp when block was mined
     *@return Date object, date when block was appended to blockchain
     */
    declare function getTime(): Date;
}
declare class NJSTezosLikeTransactionBuilder
{
    /**
     * Set type of operation (transaction, origination, reveal ...)
     * Default operation is "transaction" type
     */
    declare function setType(type: TezosOperationTag): NJSTezosLikeTransactionBuilder;
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSTezosLikeTransactionBuilder;
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function wipeToAddress(address: string): NJSTezosLikeTransactionBuilder;
    /**
     * Set fees (in drop) the originator is willing to pay
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setFees(fees: NJSAmount): NJSTezosLikeTransactionBuilder;
    /**
     * Set gas limit the originator is not willing to exceed.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setGasLimit(gasLimit: NJSAmount): NJSTezosLikeTransactionBuilder;
    /**
     * Set storage limit the originator is not willing to exceed.
     * Reference : https://tezos.gitlab.io/zeronet/whitedoc/michelson.html
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setStorageLimit(storageLimit: NJSBigInt): NJSTezosLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSTezosLikeTransactionCallback);
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSTezosLikeTransactionBuilder;
    /** Reset the current instance to its initial state */
    declare function reset();
    static declare function parseRawUnsignedTransaction(currency: Currency, rawTransaction: Object): NJSTezosLikeTransaction;
    static declare function parseRawSignedTransaction(currency: Currency, rawTransaction: Object): NJSTezosLikeTransaction;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSTezosLikeTransactionCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSTezosLikeTransaction, error: ?Error);
}
/**Class representing a Tezos account */
declare class NJSTezosLikeAccount
{
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    declare function broadcastTransaction(transaction: NJSTezosLikeTransaction, callback: NJSStringCallback);
    declare function buildTransaction(): NJSTezosLikeTransactionBuilder;
    /**
     * Get needed storage to proceed a tx
     * @param address to which we want to send tx
     * @return needed storage to interact with address/contract
     * Note: same note as for getGasPrice method on EthereumLikeAccount
     */
    declare function getStorage(address: string, callback: NJSBigIntCallback);
    /**
     * Get estimated gas limit to set so the transaction will succeed
     * The passed address could be implicit address or contract
     * This estimation is based on X last incoming txs (to address) that succeeded
     * Note: same note as for getFees method on BitcoinLikeAccount
     */
    declare function getEstimatedGasLimit(address: string, callback: NJSBigIntCallback);
    /** Get fees from network */
    declare function getFees(callback: NJSBigIntCallback);
    /** Get originated accounts by current account */
    declare function getOriginatedAccounts(): Array<NJSTezosLikeOriginatedAccount>;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSStringCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?string, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSBigIntCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSBigInt, error: ?Error);
}
/** Class representing originated accounts */
declare class NJSTezosLikeOriginatedAccount
{
    /** Get address of originated account (prefixed with KT) */
    declare function getAddress(): string;
    /**
     * Get publicKey of originated account
     * Could be empty if not yet revealed
     */
    declare function getPublicKey(): ?string;
    /** Get balance of originated account */
    declare function getBalance(callback: NJSAmountCallback);
    /** Get balance history of originated account */
    declare function getBalanceHistory(start: Date, end: Date, period: TimePeriod, callback: NJSAmountListCallback);
    /**
     * Know if possible to spend from this account
     * By default originations from libcore set it to true
     */
    declare function isSpendable(): boolean;
    /**
     * Know if possible to delegate from this account
     * By default originations from libcore set it to true
     */
    declare function isDelegatable(): boolean;
    /** Get related operations to account */
    declare function queryOperations(): NJSOperationQuery;
    /** Get builder to construct transaction on originated account */
    declare function buildTransaction(): NJSTezosLikeTransactionBuilder;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSAmountCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSAmount, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSAmountListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAmount>, error: ?Error);
}
declare class NJSTezosConfiguration
{
}
declare class NJSTezosConfigurationDefaults
{
}
/**
 * TODO: to be more accurate, all RippleLikeBlock classes should be renamed as RippleLikeLedger,
 * since there is an analogy between block and ledger concepts it's ok for the moment ...
 *Class representing a Ripple transaction
 */
declare class NJSRippleLikeTransaction
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get Fees (in drop) */
    declare function getFees(): NJSAmount;
    /** Get destination XRP address */
    declare function getReceiver(): NJSRippleLikeAddress;
    /** Get XRP sender address */
    declare function getSender(): NJSRippleLikeAddress;
    /** Get amount of XRP to send */
    declare function getValue(): NJSAmount;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Set signature of transaction, when a signature is set serialize method gives back serialized Tx */
    declare function setSignature(rSignature: Object, sSignature: Object);
    declare function setDERSignature(signature: Object);
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction
     */
    declare function getDate(): Date;
    /**
     * Get block to which transaction belongs (was mined in)
     *getBlock(): optional<RippleLikeBlock>;
     * Get sequence of an account when tx was built (number of sent transactions from an account)
     */
    declare function getSequence(): NJSBigInt;
    /** Get Ledger's sequence in which the tx was included */
    declare function getLedgerSequence(): NJSBigInt;
    /** Get Signing public Key */
    declare function getSigningPubKey(): Object;
    /** Get all memos associated with the transaction. */
    declare function getMemos(): Array<RippleLikeMemo>;
    /** Add a memo to a transaction. */
    declare function addMemo(memo: RippleLikeMemo);
    /** An arbitrary unsigned 32-bit integer that identifies a reason for payment or a non-Ripple account */
    declare function getDestinationTag(): ?number;
    /** Status of the transaction. */
    declare function getStatus(): number;
}
/**Class representing a Ripple Operation */
declare class NJSRippleLikeOperation
{
    /**
     *Get operation's transaction
     *@return RippleLikeTransaction object
     */
    declare function getTransaction(): NJSRippleLikeTransaction;
}
/**Class representing Ripple block */
declare class NJSRippleLikeBlock
{
    /**
     *Hash of block
     *@return string representing hash of this block
     */
    declare function getHash(): string;
    /**
     *Height of block in blockchain
     *@return 64 bits integer, height of block
     */
    declare function getHeight(): number;
    /**
     *Timestamp when block was mined
     *@return Date object, date when block was appended to blockchain
     */
    declare function getTime(): Date;
}
declare class NJSRippleLikeTransactionBuilder
{
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSRippleLikeTransactionBuilder;
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function wipeToAddress(address: string): NJSRippleLikeTransactionBuilder;
    /**
     * Set fees (in drop) the originator is willing to pay
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setFees(fees: NJSAmount): NJSRippleLikeTransactionBuilder;
    /**
     * Add a memo.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addMemo(memo: RippleLikeMemo): NJSRippleLikeTransactionBuilder;
    /** An arbitrary unsigned 32-bit integer that identifies a reason for payment or a non-Ripple account */
    declare function setDestinationTag(tag: number): NJSRippleLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSRippleLikeTransactionCallback);
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSRippleLikeTransactionBuilder;
    /** Reset the current instance to its initial state */
    declare function reset();
    static declare function parseRawUnsignedTransaction(currency: Currency, rawTransaction: Object): NJSRippleLikeTransaction;
    static declare function parseRawSignedTransaction(currency: Currency, rawTransaction: Object): NJSRippleLikeTransaction;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSRippleLikeTransactionCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSRippleLikeTransaction, error: ?Error);
}
/**Class representing a Ripple account */
declare class NJSRippleLikeAccount
{
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    declare function broadcastTransaction(transaction: NJSRippleLikeTransaction, callback: NJSStringCallback);
    declare function buildTransaction(): NJSRippleLikeTransactionBuilder;
    /**
     * Get fees from network
     * Note: it would have been better to have this method on RippleLikeWallet
     * but since RippleLikeWallet is not used anywhere, it's better to keep all
     * specific methods under the same specific class so it will be easy to segratate
     * when the right time comes !
     */
    declare function getFees(callback: NJSAmountCallback);
    /**
     * Get base reserve (dust to leave on an XRP account) from network
     * Note: same note as above
     */
    declare function getBaseReserve(callback: NJSAmountCallback);
    /**
     * Check whether an account has been activated or not
     * Here activation, means that the XRP account received a first transaction with a minimum amount
     * greater or equal to XRP base reserve
     * @param: address to check
     * @return: true if valid address and has been activated, false otherwise
     */
    declare function isAddressActivated(address: string, isActivated: NJSBoolCallback);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSBoolCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?boolean, error: ?Error);
}
declare class NJSRippleConfiguration
{
}
declare class NJSRippleConfigurationDefaults
{
}
/**Class implementing secp256k1 used in Bitcoin. */
declare class NJSSecp256k1
{
    /**
     * Create an instance of Secp256k1.
     * @return Secp256k1 instance
     */
    static declare function createInstance(): NJSSecp256k1;
    /**
     * Generates public key from private key.
     * @param privKey 32 byte private key
     * @param compress get compressed (35 bytes) or uncompressed (65 bytes)
     * @return public key can be compressed (35 bytes starting with 02 or 03) or un compressed (65 bytes starting with 04)
     */
    declare function computePubKey(privKey: Object, compress: boolean): Object;
    /**
     * Generates uncompressed public key from compressed public key.
     * @param pubKey 33 byte private key (starting with 02 or 03)
     * @return uncompressed public key (65 bytes starting with 04)
     */
    declare function computeUncompressedPubKey(pubKey: Object): Object;
    /**
     * Signs message using a given private key.
     * @param privKey 32 bytes private key
     * @param data 32 bytes message to sign
     * @return 32 bytes signed message
     */
    declare function sign(privKey: Object, data: Object): Object;
    /**
     * Check if message was signed with given signature and public key.
     * @param data 32 bytes signed message
     * @param signature 32 bytes signature (generated from private key)
     * @param oubkey 32 bytes public key
     * @return true if message was signed with signature and public key (both issued from same private key)
     */
    declare function verify(data: Object, signature: Object, pubKey: Object): boolean;
    static declare function newInstance(): NJSSecp256k1;
}
/** All available blockchain networks parameters. */
declare class NJSNetworks
{
    /** The Bitcoin network parameters. */
    static declare function bitcoin(): BitcoinLikeNetworkParameters;
    /** The Ethereum network parameters. */
    static declare function ethereum(): EthereumLikeNetworkParameters;
    /** The Ripple network parameters. */
    static declare function ripple(): RippleLikeNetworkParameters;
    /** The Tezos network parameters. */
    static declare function tezos(): TezosLikeNetworkParameters;
}
/** Helper class for commonly used crypto algorithms. */
declare class NJSHashAlgorithmHelper
{
    /**
     * RACE Integrity Primitives Evaluation Message Digest (used in Bitcoin).
     * @param data in bytes, message to hash
     * @return 160 bits hashed message
     */
    declare function ripemd160(data: Object): Object;
    /**
     * Secure Hash Algorithm (used in Bitcoin).
     * @param data in bytes, message to hash
     * @return 256 bits hashed message
     */
    declare function sha256(data: Object): Object;
    /**
     * Hash algorithm used in ethereum.
     * @param data in bytes, message to hash
     * @return 256 bits hashed message
     */
    declare function keccak256(data: Object): Object;
}
declare class NJSStellarLikeBlock
{
}
declare class NJSStellarLikeTransaction
{
    declare function toRawTransaction(): Object;
    /** Returns the payload which should be signed by the user in order to send the transaction. */
    declare function toSignatureBase(): Object;
    /** Add a new signature to the transaction envelope */
    declare function putSignature(signature: Object, address: NJSAddress);
    /** Returns the author of the transaction */
    declare function getSourceAccount(): NJSAddress;
    /** Returns the sequence of the source account used for this transaction */
    declare function getSourceAccountSequence(): NJSBigInt;
    /** Returns the fee paid for this transaction to be validated */
    declare function getFee(): NJSAmount;
}
declare class NJSStellarLikeTransactionBuilder
{
    declare function addNativePayment(address: string, amount: NJSAmount): NJSStellarLikeTransactionBuilder;
    declare function addCreateAccount(address: string, amount: NJSAmount): NJSStellarLikeTransactionBuilder;
    declare function setBaseFee(baseFee: NJSAmount): NJSStellarLikeTransactionBuilder;
    declare function setTextMemo(text: string): NJSStellarLikeTransactionBuilder;
    declare function setNumberMemo(number: NJSBigInt): NJSStellarLikeTransactionBuilder;
    declare function setHashMemo(hash: Object): NJSStellarLikeTransactionBuilder;
    declare function setReturnMemo(value: Object): NJSStellarLikeTransactionBuilder;
    declare function setSequence(sequence: NJSBigInt): NJSStellarLikeTransactionBuilder;
    declare function build(callback: NJSStellarLikeTransactionCallback);
    static declare function parseRawTransaction(currency: Currency, rawTransaction: Object): NJSStellarLikeTransaction;
    static declare function parseSignatureBase(currency: Currency, rawTransaction: Object): NJSStellarLikeTransaction;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSStellarLikeTransactionCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSStellarLikeTransaction, error: ?Error);
}
declare class NJSStellarLikeOperation
{
    /** Get the underlying operation information */
    declare function getRecord(): StellarLikeOperationRecord;
    /** Get the underlying transaction in which this operation can be found. */
    declare function getTransaction(): NJSStellarLikeTransaction;
}
declare class NJSStellarLikeAccount
{
    /**
     * Checks if the current account exists on the stellar Network. If it doesn't the account needs to be activated by
     * sending an account creation operation with an amount of at least the base reserve.
     * @return Callback with a boolean indicating if the account exists on the Stellar network or not.
     */
    declare function exists(callback: NJSBoolCallback);
    /**
     * Create a new transaction builder to create new transaction
     * @return The transaction builder
     */
    declare function buildTransaction(): NJSStellarLikeTransactionBuilder;
    /** Broadcast the given raw transaction to the network. */
    declare function broadcastRawTransaction(tx: Object, callback: NJSStringCallback);
    /** Get base reserve of the network */
    declare function getBaseReserve(callback: NJSAmountCallback);
    /** Get sequence number to be used in the next transaction */
    declare function getSequence(callback: NJSBigIntCallback);
    /** Get recommended fee */
    declare function getFeeStats(callback: NJSStellarLikeFeeStatsCallback);
    /** Get signers for this account */
    declare function getSigners(callback: NJSStellarLikeAccountSignerListCallback);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSStellarLikeFeeStatsCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?StellarLikeFeeStats, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSStellarLikeAccountSignerListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<StellarLikeAccountSigner>, error: ?Error);
}
declare class NJSStellarLikeWallet
{
    declare function exists(address: string, callback: NJSBoolCallback);
}
declare class NJSStellarLikeAddress
{
}
/** Class representing an event. */
declare class NJSEvent
{
    /**
     * Get event code (for more details, please refer to EventCode enum).
     * @return EventCode enum entry
     */
    declare function getCode(): EventCode;
    /**
     * Get payload of event.
     * @return DynamicObject object
     */
    declare function getPayload(): NJSDynamicObject;
    /**
     * Tell whether the event is a sticky one.
     * @return bool
     */
    declare function isSticky(): boolean;
    /**
     * If event is sticky, return sticky tag.
     * @return 32 bits integer
     */
    declare function getStickyTag(): number;
    /**
     * Create a new instance of Event class.
     * @param code, EventCode enum entry
     * @param payload, DynamicObject object
     * @return Event instance
     */
    static declare function newInstance(code: EventCode, payload: NJSDynamicObject): NJSEvent;
}
/** Class respresenting an event receiver. */
declare class NJSEventReceiver
{
    /**
     * Method triggered when an event occurs.
     * @param event, Event object that triggers this method
     */
    declare function onEvent(event: NJSEvent);
}
/** Class representing an event bus through which a receiver gets notified. */
declare class NJSEventBus
{
    /**
     * Subscribe an event receiver to the event bus.
     * @param context, ExecutionContext object, execution context in which receiver will be notified
     * @param reveiver, EventReceiver object, receiver that event bu will notify
     */
    declare function subscribe(context: NJSExecutionContext, receiver: NJSEventReceiver);
    /**
     * Unsubscribe an event receiver from the event bus.
     * @param receiver, EventReceiver object, receiver to unsubscribe
     */
    declare function unsubscribe(receiver: NJSEventReceiver);
}
/** Class representing an event publisher. */
declare class NJSEventPublisher
{
    /**
     * Get event bus through which publisher broadcast its events.
     * @return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     * Broadcast an event through eventbus (to all subscribed receivers to this EventBus).
     * @param event, Event object
     */
    declare function post(event: NJSEvent);
    /**
     * Same as post method but with an sticky event.
     * @param event, Event object
     * @param tag, 32 bits integer, tag of sticky event
     */
    declare function postSticky(event: NJSEvent, tag: number);
    /**
     * Relay an event to another EventBus (other than EventPublisher's event bus).
     * @param bus, EventBus object, through which we want to broadcast EventPublisher's event to EventPublisher's receiver
     */
    declare function relay(bus: NJSEventBus);
    /**
     * Create a new instance of EventPublisher class.
     * @param context, executionContext object, context in which event publisher broadcast its events
     */
    static declare function newInstance(context: NJSExecutionContext): NJSEventPublisher;
}
/** Class of synchronization status constants. */
declare class NJSSynchronizationStatus
{
}
declare class NJSDerivationPath
{
    /** Get the number of element in this path. */
    declare function getDepth(): number;
    /** Get the child num at the given index in the path. */
    declare function getChildNum(index: number): number;
    /**
     * Get the child num at the given index in the path. If the child num is hardened, returns it
     * without the hardened marker bit.
     */
    declare function getUnhardenedChildNum(index: number): number;
    /** Return true if the given index in the path is an hardened child num. */
    declare function isHardened(index: number): boolean;
    /** Serialize the given path to a human readable string like "44'/0'/0'/0/0". */
    declare function toString(): string;
    /**
     * Return a derivation path without the last element, e.g. the parent of "44'/0'/0'/0/0" is
     * "44'/0'/0'/0".
     */
    declare function getParent(): NJSDerivationPath;
    /** Return an array where which item is a child num of the path. */
    declare function toArray(): Array<number>;
    static declare function parse(path: string): NJSDerivationPath;
}
/** The trust indicator of an operation. */
declare class NJSTrustIndicator
{
    declare function getTrustWeight(): number;
    declare function getTrustLevel(): TrustLevel;
    declare function getConflictingOperationUids(): Array<string>;
    declare function getOrigin(): string;
}
/** Class representing an operation. */
declare class NJSOperation
{
    /**
     * Get id's operation.
     * @return string
     */
    declare function getUid(): string;
    /**
     * Get account's index in user's wallet.
     * @return 32-bit integer
     */
    declare function getAccountIndex(): number;
    /**
     * Get type of operation.
     * @return OperationType object (for more details refer to OperationType)
     */
    declare function getOperationType(): OperationType;
    /**
     * Return date on which operation was issued.
     * @return date object
     */
    declare function getDate(): Date;
    /**
     * Get senders of operation.
     * @return List of string, list of all senders
     */
    declare function getSenders(): Array<string>;
    /**
     * Get recipients of operation.
     * @return List of string, list of all recipients
     */
    declare function getRecipients(): Array<string>;
    /**
     * Get amount of operation.
     * @return Amount object
     */
    declare function getAmount(): NJSAmount;
    /**
     * Get fees of operation.
     * @return Optional Amount object
     */
    declare function getFees(): ?NJSAmount;
    /**
     * Get preferences of operation.
     * @return Prefences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     * Get trust indicator of operation.
     * @return TrustIndicator object
     */
    declare function getTrust(): NJSTrustIndicator;
    /**
     * Get block height on which operation was included.
     * @return Optional 64-bit integer, height of block in which operation was validated
     */
    declare function getBlockHeight(): ?number;
    /**
     * Convert operation as Bitcoin operation.
     * @return BitcoinLikeOperation object
     */
    declare function asBitcoinLikeOperation(): NJSBitcoinLikeOperation;
    /**
     * Convert operation as Ethereum operation.
     * @return EthereumLikeOperation object
     */
    declare function asEthereumLikeOperation(): NJSEthereumLikeOperation;
    /**
     *Convert operation as Ripple operation
     *@return RippleLikeOperation object
     */
    declare function asRippleLikeOperation(): NJSRippleLikeOperation;
    /**
     *Convert operation as Tezos operation
     *@return TezosLikeOperation object
     */
    declare function asTezosLikeOperation(): NJSTezosLikeOperation;
    /**
     * Same as isInstanceOfBitcoinLikeOperation for bitcoin.
     * Convert operation as Ethereum operation.
     * @return EthereumLikeOperation object
     */
    declare function asStellarLikeOperation(): NJSStellarLikeOperation;
    /** Is this an instance of a Bitcoin-like operation? */
    declare function isInstanceOfBitcoinLikeOperation(): boolean;
    /** Same as isInstanceOfEthereumLikeOperation for ethereum. */
    declare function isInstanceOfEthereumLikeOperation(): boolean;
    /** Same as isInstanceOfRippleLikeOperation for ripple. */
    declare function isInstanceOfRippleLikeOperation(): boolean;
    /** Same as isInstanceOfTezosLikeOperation for tezos. */
    declare function isInstanceOfTezosLikeOperation(): boolean;
    /** Same as isInstanceOfBitcoinLikeOperation for ripple. */
    declare function isInstanceOfStellarLikeOperation(): boolean;
    /**
     * Tells if the operation is complete.
     * @return boolean
     */
    declare function isComplete(): boolean;
    /**
     * Get type of wallet from which operation was issued.
     * @return WalletType object
     */
    declare function getWalletType(): WalletType;
    /** Get the currency this operation is about. */
    declare function getCurrency(): Currency;
}
/**TODO */
declare class NJSQueryFilter
{
    static declare function accountEq(accountUid: string): NJSQueryFilter;
    static declare function accountNeq(accountUid: string): NJSQueryFilter;
    static declare function dateLte(time: Date): NJSQueryFilter;
    static declare function dateLt(time: Date): NJSQueryFilter;
    static declare function dateGt(time: Date): NJSQueryFilter;
    static declare function dateGte(time: Date): NJSQueryFilter;
    static declare function dateEq(time: Date): NJSQueryFilter;
    static declare function dateNeq(time: Date): NJSQueryFilter;
    static declare function containsRecipient(recipientAddress: string): NJSQueryFilter;
    static declare function containsSender(senderAddress: string): NJSQueryFilter;
    static declare function currencyEq(currencyName: string): NJSQueryFilter;
    static declare function operationUidEq(operationUid: string): NJSQueryFilter;
    static declare function operationUidNeq(operationUid: string): NJSQueryFilter;
    static declare function trustEq(trust: TrustLevel): NJSQueryFilter;
    static declare function trustNeq(trust: TrustLevel): NJSQueryFilter;
    static declare function feesEq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGt(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountEq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLt(amount: NJSAmount): NJSQueryFilter;
    static declare function blockHeightEq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightNeq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightIsNull(): NJSQueryFilter;
    static declare function operationTypeEq(operationType: OperationType): NJSQueryFilter;
    static declare function operationTypeNeq(operationType: OperationType): NJSQueryFilter;
    declare function op_and(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_and_not(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or_not(filter: NJSQueryFilter): NJSQueryFilter;
}
/** Class respresenting a query for a set of operations. */
declare class NJSOperationQuery
{
    /**
     * Apply given order to query's operation.
     * @param key, OperationOrderKey object which defines order
     * @param descending, bool
     * @return OperationQuery object, new ordered operation
     */
    declare function addOrder(key: OperationOrderKey, descending: boolean): NJSOperationQuery;
    /**
     * Get applied filter on operation query.
     * @return QueryFilter object
     */
    declare function filter(): NJSQueryFilter;
    /**
     * Add offset to the operation query.
     * @param from, 64-bit integer
     */
    declare function offset(from: number): NJSOperationQuery;
    /**
     * Add limit to the operation query results.
     * @param count, 64-bit integer
     */
    declare function limit(count: number): NJSOperationQuery;
    /**
     *TODO
     * Complete the operation query.
     */
    declare function complete(): NJSOperationQuery;
    /**TODO */
    declare function partial(): NJSOperationQuery;
    /**
     * Execute query to retrieve operations.
     * @param callback, if execute method succeed, ListCallback object returning a List of Operation objects
     */
    declare function execute(callback: NJSOperationListCallback);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSOperationListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSOperation>, error: ?Error);
}
declare class NJSAddress
{
    /**
     * Gets an optional derivation path (if the address is owned by an account).
     * @return The derivation path of the address
     */
    declare function getDerivationPath(): ?string;
    /**
     * Serialize the address to a string. The serialization method depends of the underlying currency and
     * format (Base58, Bech32, Ethereum...).
     */
    declare function toString(): string;
    declare function asBitcoinLikeAddress(): ?NJSBitcoinLikeAddress;
    declare function isInstanceOfBitcoinLikeAddress(): boolean;
    /** Cast the address to a stellar like one */
    declare function asStellarLikeAddress(): ?NJSStellarLikeAddress;
    declare function isInstanceOfStellarLikeAddress(): boolean;
    declare function getCurrency(): Currency;
    /**
     * Attempt to parse a string address. If the address can be parse return it otherwise return a NONE
     * (depending on you host this may be a null, nil, None...).
     * @param address The string to parse
     * @param currency The currency used to parse the address
     * @return If successful returns the address object otherwise null.
     */
    static declare function parse(address: string, currency: Currency): ?NJSAddress;
    /**
     * Checks if the given string formatted address is valid or not.
     * @param address The string to parse
     * @param currency The currency used to parse the address
     * @return If successful returns true, false otherwise.
     */
    static declare function isValid(address: string, currency: Currency): boolean;
}
/** Class representing an account. */
declare class NJSAccount
{
    /**
     * Get index of account in user's wallet
     * 32-bit integer
     */
    declare function getIndex(): number;
    /** Get the list of all operations. */
    declare function queryOperations(): NJSOperationQuery;
    /**
     * Get balance of account.
     * @param callback, if getBalacne, Callback returning an Amount object which represents account's balance
     */
    declare function getBalance(callback: NJSAmountCallback);
    /**
     * Get balance of account at a precise interval with a certain granularity.
     * @param start, lower bound of search range
     * @param end, upper bound of search range
     * @param precision, granularity at which we want results
     * @param callback, ListCallback returning a list of Amount object which represents account's balance
     */
    declare function getBalanceHistory(start: string, end: string, period: TimePeriod, callback: NJSAmountListCallback);
    /**
     * Get synchronization status of account.
     * @return bool
     */
    declare function isSynchronizing(): boolean;
    /**
     * Start synchronization of account.
     * @return EventBus, handler will be notified of synchronization outcome
     */
    declare function synchronize(): NJSEventBus;
    /**
     * Return account's preferences.
     * @return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     * Return account's logger which provides all needed (e.g. database) logs.
     * @return Logger Object
     */
    declare function getLogger(): NJSLogger;
    /**
     * Return operation for a specific operation.
     * @param uid, string of operation id
     */
    declare function getOperationPreferences(uid: string): NJSPreferences;
    /**
     * Turn the account into an Bitcoin one, allowing operations to be performed on the Bitcoin
     * network.
     */
    declare function asBitcoinLikeAccount(): NJSBitcoinLikeAccount;
    /**
     * Turn the account into an Ethereum one, allowing operations to be performrd on the Ethereum
     * network.
     */
    declare function asEthereumLikeAccount(): NJSEthereumLikeAccount;
    /** Turn the account into a Ripple one, allowing operations to be performed on the Ripple network. */
    declare function asRippleLikeAccount(): NJSRippleLikeAccount;
    /** Turn the account into a Tezos one, allowing operations to be performed on the Tezos network. */
    declare function asTezosLikeAccount(): NJSTezosLikeAccount;
    /**
     * Turn the account into a Stellar one, allowing operations to be performerd on the Stellar
     * network.
     */
    declare function asStellarLikeAccount(): NJSStellarLikeAccount;
    /**
     * Check if account is a Bitcoin one.
     * @return bool
     */
    declare function isInstanceOfBitcoinLikeAccount(): boolean;
    /**
     * Check if account is an Ethereum one.
     * @return bool
     */
    declare function isInstanceOfEthereumLikeAccount(): boolean;
    /**
     * Check if account is a Stellar one.
     * @return bool
     */
    declare function isInstanceOfStellarLikeAccount(): boolean;
    /**
     * Check if account is a Ripple one.
     * @return bool
     */
    declare function isInstanceOfRippleLikeAccount(): boolean;
    /**TODO */
    declare function getFreshPublicAddresses(callback: NJSAddressListCallback);
    /**
     * Get type of wallet to which account belongs.
     * @return WalletType object
     */
    declare function getWalletType(): WalletType;
    /**
     * Get event bus through which account is notified on synchronization status.
     * @return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /** Start observing blockchain on which account synchronizes and send/receive transactions. */
    declare function startBlockchainObservation();
    /** Stop observing blockchain. */
    declare function stopBlockchainObservation();
    /**
     * Get account's observation status.
     * @return boolean
     */
    declare function isObservingBlockchain(): boolean;
    /**
     * Get Last block of blockchain on which account operates.
     * @param callback, Callback returning, if getLastBlock succeeds, a Block object
     */
    declare function getLastBlock(callback: NJSBlockCallback);
    /** Get the key used to generate the account. */
    declare function getRestoreKey(): string;
    /**
     * Erase data (in user's DB) relative to wallet since given date.
     * @param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSAddressListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAddress>, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSBlockCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Block, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSErrorCodeCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?ErrorCode, error: ?Error);
}
/** Class representing a wallet. */
declare class NJSWallet
{
    /**
     * Get name of wallet.
     * @return string
     */
    declare function getName(): string;
    /**
     * Get account with specific index.
     * @param index, 32-bit integer, index of account in wallet
     * @param callback, Callback returning, if getAccount succeed, an Account object with given index
     */
    declare function getAccount(index: number, callback: NJSAccountCallback);
    /**
     * Get number of accounts instanciated under wallet.
     * @param callback, Callback returning, if getAccountCount succeed, a 32-bit integer representing number of accounts
     */
    declare function getAccountCount(callback: NJSI32Callback);
    /**
     * Get list of accounts instanciated under wallet in a given range.
     * @param offset, 32-bit integer from which we retrieve accounts
     * @param count, 32-bit integer, number of accounts to retrieve
     * @param callback, ListCallback returning, if getAccounts succeed, list of Accounts object
     */
    declare function getAccounts(offset: number, count: number, callback: NJSAccountListCallback);
    /**
     * Get index of next account to create.
     * @return callback, Callback returning a 32-bit integer
     */
    declare function getNextAccountIndex(callback: NJSI32Callback);
    /**
     * Return event bus through which wallet synchronizes it's accounts and interact with blockchain.
     * @return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     * Return synchronization status wallet, true if at least one of accounts is synchronizing.
     * @return bool
     */
    declare function isSynchronizing(): boolean;
    /**
     * Start synchronization of all accounts under wallet.
     * @return EventBus object through which wallet get notified of account's synchronization status
     */
    declare function synchronize(): NJSEventBus;
    /**
     * Get wallet preferences.
     * @return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     * Return account's logger which provides all needed (e.g. database) logs.
     * @return Logger Object
     */
    declare function getLogger(): NJSLogger;
    /**
     * Get preferences of specific account.
     * @param index, 32-bit integer, account's index
     * @return Preferences object
     */
    declare function getAccountPreferences(index: number): NJSPreferences;
    /**
     * Convert wallet to a Bitcoin one.
     * @return BitcoinWallet object
     */
    declare function asBitcoinLikeWallet(): NJSBitcoinLikeWallet;
    /**
     * Get currency of wallet.
     * @return Currency object
     */
    declare function getCurrency(): Currency;
    /**
     * Tell whether wallet is a Bitcoin one.
     * @return bool
     */
    declare function isInstanceOfBitcoinLikeWallet(): boolean;
    /**
     * Tell whether wallet is a Ethereum one.
     * @return bool
     */
    declare function isInstanceOfEthereumLikeWallet(): boolean;
    /**
     * Tell whether wallet is a Ripple one.
     * @return bool
     */
    declare function isInstanceOfRippleLikeWallet(): boolean;
    /**
     * Tell whether wallet is a Stellar one.
     * @return bool
     */
    declare function isInstanceOfStellarLikeWallet(): boolean;
    /** Cast the instance to StellarLIkeWallet */
    declare function asStellarLikeWallet(): NJSStellarLikeWallet;
    /**
     * Get wallet type.
     * @return WalletType object
     */
    declare function getWalletType(): WalletType;
    /**
     * Get last block of blockchain the wallet operates on.
     * @param callback, Callback returning a Block object
     */
    declare function getLastBlock(callback: NJSBlockCallback);
    /**
     * Return infos about the creation of specific account.
     * @param accountIndex, 32-bit account, index of account in wallet
     * @param callback, Callback returning an AccountCreationInfo
     */
    declare function getAccountCreationInfo(accountIndex: number, callback: NJSAccountCreationInfoCallback);
    /**TODO */
    declare function getExtendedKeyAccountCreationInfo(accountIndex: number, callback: NJSExtendedKeyAccountCreationInfoCallback);
    /**
     * Return infos about the next created account.
     * @param callback, Callback returning an AccountCreationInfo
     */
    declare function getNextAccountCreationInfo(callback: NJSAccountCreationInfoCallback);
    /**TODO */
    declare function getNextExtendedKeyAccountCreationInfo(callback: NJSExtendedKeyAccountCreationInfoCallback);
    /**
     * Get account from given account creation infos.
     * @param accountCreationInfo, AccountCreationInfo object
     * @param callback, Callback returning an Account object with given creation infos
     */
    declare function newAccountWithInfo(accountCreationInfo: AccountCreationInfo, callback: NJSAccountCallback);
    /**TODO */
    declare function newAccountWithExtendedKeyInfo(extendedKeyAccountCreationInfo: ExtendedKeyAccountCreationInfo, callback: NJSAccountCallback);
    /**
     * Erase data (in user's DB) relative to wallet since given date.
     * @param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
    /** Return wallet's configuration */
    declare function getConfiguration(): NJSDynamicObject;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSAccountCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSAccount, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSI32Callback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?number, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSAccountListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAccount>, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSAccountCreationInfoCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?AccountCreationInfo, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSExtendedKeyAccountCreationInfoCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?ExtendedKeyAccountCreationInfo, error: ?Error);
}
/** A collection of dynamic values in an array. Values can be retrieved via their indexes. */
declare class NJSDynamicArray
{
    /**
     * Get count of values.
     * @return 64-bit integer
     */
    declare function size(): number;
    /**
     * Push a 32-bit integer.
     * @param value, 32-bit integer
     * @return DynamicArray with value stored in it
     */
    declare function pushInt(value: number): NJSDynamicArray;
    /**
     * Push a 64-bit integer.
     * @param value, 64-bit integer
     * @return DynamicArray with value stored in it
     */
    declare function pushLong(value: number): NJSDynamicArray;
    /**
     * Push a string.
     * @param value, string
     * @return DynamicArray with value stored in it
     */
    declare function pushString(value: string): NJSDynamicArray;
    /**
     * Push a double.
     * @param value, double
     * @return DynamicArray with value stored in it
     */
    declare function pushDouble(value: number): NJSDynamicArray;
    /**
     * Push a binary.
     * @param value, binary
     * @return DynamicArray with value stored in it
     */
    declare function pushData(value: Object): NJSDynamicArray;
    /**
     * Push a bool.
     * @param value, bool
     * @return DynamicArray with value stored in it
     */
    declare function pushBoolean(value: boolean): NJSDynamicArray;
    /**
     * Push a dynamic object.
     * @param value, DynamicObject
     * @return DynamicArray with value stored in it
     */
    declare function pushObject(value: NJSDynamicObject): NJSDynamicArray;
    /**
     * Push a dynamic array.
     * @param value, DynamicArray
     * @return DynamicArray with value stored in it
     */
    declare function pushArray(value: NJSDynamicArray): NJSDynamicArray;
    /**
     * Get a string at a given index.
     * @param index, 64-bit integer
     * @return Optional string
     */
    declare function getString(index: number): ?string;
    /**
     * Get 32-bit integer at a given index.
     * @param index, 64-bit integer
     * @return Optional 32-bit integer
     */
    declare function getInt(index: number): ?number;
    /**
     * Get 64-bit integer at a given index.
     * @param index, 64-bit integer
     * @return Optional 64-bit integer
     */
    declare function getLong(index: number): ?number;
    /**
     * Get double at a given index.
     * @param index, 64-bit integer
     * @return Optional double
     */
    declare function getDouble(index: number): ?number;
    /**
     * Get binary at a given index.
     * @param index, 64-bit integer
     * @return Optional binary
     */
    declare function getData(index: number): ?Object;
    /**
     * Get bool at a given index.
     * @param index, 64-bit integer
     * @return Optional bool
     */
    declare function getBoolean(index: number): ?boolean;
    /**
     * Get DynamicObject object at a given index.
     * @param index, 64-bit integer
     * @return Optional DynamicObject
     */
    declare function getObject(index: number): ?NJSDynamicObject;
    /**
     * Get DynamicArray object at a given index.
     * @param index, 64-bit integer
     * @return Optional DynamicArray
     */
    declare function getArray(index: number): ?NJSDynamicArray;
    /**
     * Concatenate current DynamicArray with another one.
     * @param array, DynamicArray object to concatenate with
     * @return DynamicArray object, concatenated DynamicArray
     */
    declare function concat(array: NJSDynamicArray): NJSDynamicArray;
    /**
     * Get type of value stored at a given index.
     * @param index, 64 bits integer
     * @return Optional DynamicType enum entry
     */
    declare function getType(index: number): ?DynamicType;
    /**
     * Delete value stored at given index.
     * @param index, 64 bits integer
     * @return bool, true if deletion succeeded
     */
    declare function remove(index: number): boolean;
    /**
     * Dump whole object's content as string.
     * @return string, the string representation of the array
     */
    declare function dump(): string;
    /**
     * Serialize whole object to a binary.
     * @return binary, the serialized array
     */
    declare function serialize(): Object;
    /**
     * Get readonly status of object.
     * @return bool, whether the array is in read-only mode
     */
    declare function isReadOnly(): boolean;
    /**
     * Create a new instance of DynamicArray class.
     * @return DynamicArray, a brand new instance of a dynamic array
     */
    static declare function newInstance(): NJSDynamicArray;
    /**
     * Parse a binary to a DynamicArray.
     * @param serialized, binary to parse
     * @return Optional, the unserialized dynamic array
     */
    static declare function load(serialized: Object): ?NJSDynamicArray;
}
/**
 * Class representing an object that stores values of different types of objects,
 * those values are appended dynamically in a map like structure with a given key through which they
 * can be retreived.
 */
declare class NJSDynamicObject
{
    /**
     * Store a string with a given key.
     * @param key, string, key to access stored value
     * @param value, string
     * @return DynamicObject object with value stored in it
     */
    declare function putString(key: string, value: string): NJSDynamicObject;
    /**
     * Store a 32-bit integer with a given key.
     * @param key, string, key to access stored value
     * @param value, 32-bit integer
     * @return DynamicObject object with value stored in it
     */
    declare function putInt(key: string, value: number): NJSDynamicObject;
    /**
     * Store a 64-bit integer with a given key.
     * @param key, string, key to access stored value
     * @param value, 64-bit integer
     * @return DynamicObject object with value stored in it
     */
    declare function putLong(key: string, value: number): NJSDynamicObject;
    /**
     * Store a double with a given key.
     * @param key, string, key to access stored value
     * @param value, double
     * @return DynamicObject object with value stored in it
     */
    declare function putDouble(key: string, value: number): NJSDynamicObject;
    /**
     * Store a binary integer with a given key.
     * @param key, string, key to access stored value
     * @param value, binary
     * @return DynamicObject object with value stored in it
     */
    declare function putData(key: string, value: Object): NJSDynamicObject;
    /**
     * Store a boolean integer with a given key.
     * @param key, string, key to access stored value
     * @param value, bool
     * @return DynamicObject object with value stored in it
     */
    declare function putBoolean(key: string, value: boolean): NJSDynamicObject;
    /**
     * Store another DynamicObject object with a given key.
     * @param key, string, key to access stored value
     * @return DynamicObject object with value stored in it
     */
    declare function putObject(key: string, value: NJSDynamicObject): NJSDynamicObject;
    /**
     * Store a DynamicArray object with a given key.
     * @param key, string, key to access stored reference
     * @return DynamicArray object with value stored in it
     */
    declare function putArray(key: string, value: NJSDynamicArray): NJSDynamicObject;
    /**
     * Get, if exists, stored string having a specific key.
     * @param key, string, key of string to look for
     * @return Optional string
     */
    declare function getString(key: string): ?string;
    /**
     * Get, if exists, stored 32 bits integer having a specific key.
     * @param key, string, key of 32 bits integer to look for
     * @return Optional 32 bits integer
     */
    declare function getInt(key: string): ?number;
    /**
     * Get, if exists, stored 64 bits integer having a specific key.
     * @param key, string, key of 64 bits integer to look for
     * @return Optional 64 bits integer
     */
    declare function getLong(key: string): ?number;
    /**
     * Get, if exists, stored double having a specific key.
     * @param key, string, key of double to look for
     * @return Optional double
     */
    declare function getDouble(key: string): ?number;
    /**
     * Get, if exists, stored binary having a specific key.
     * @param key, string, key of binary to look for
     * @return Optional binary
     */
    declare function getData(key: string): ?Object;
    /**
     * Get, if exists, stored bool having a specific key.
     * @param key, string, key of bool to look for
     * @return Optional bool
     */
    declare function getBoolean(key: string): ?boolean;
    /**
     * Get, if exists, stored DynamicObject having a specific key.
     * @param key, string, key of DynamicObject to look for
     * @return Optional DynamicObject
     */
    declare function getObject(key: string): ?NJSDynamicObject;
    /**
     * Get, if exists, stored DynamicArray having a specific key.
     * @param key, string, key of DynamicArray to look for
     * @return Optional DynamicArray
     */
    declare function getArray(key: string): ?NJSDynamicArray;
    /**
     * Check if a key was used to store a value.
     * @param key, string, key to look for
     * @return bool
     */
    declare function contains(key: string): boolean;
    /**
     * Delete key and value stored with it.
     * @param key, string, key to look for
     * @return bool, true if key exists and deletion succeeded, false otherwise
     */
    declare function remove(key: string): boolean;
    /**
     * Get list of keys.
     * @return list of string, list all stored keys
     */
    declare function getKeys(): Array<string>;
    /**
     * Get type of object stored with specific key.
     * @param key, string, key to look for
     * @return Optional DynamicType enum entry
     */
    declare function getType(key: string): ?DynamicType;
    /**
     * Dump whole object's content as string.
     * @return string
     */
    declare function dump(): string;
    /**
     * Serialize whole object to a binary.
     * @return binary
     */
    declare function serialize(): Object;
    /**
     * Get readonly status of object.
     * @param bool
     */
    declare function isReadOnly(): boolean;
    /**
     * Get count of stored references.
     * @return 64 bits integer
     */
    declare function size(): number;
    /**
     * Create a new instance of DynamicObject class.
     * @return DynamicObject instance
     */
    static declare function newInstance(): NJSDynamicObject;
    /**
     * Parse a binary to a DynamicObject.
     * @param serialized, binary to parse
     * @return Optional DynamicObject
     */
    static declare function load(serialized: Object): ?NJSDynamicObject;
}
/** Available API to use with Stellar wallets */
declare class NJSStellarConfiguration
{
}
/** Available API to use with explorers. */
declare class NJSBlockchainExplorerEngines
{
}
/** Available API to use with observers. */
declare class NJSBlockchainObserverEngines
{
}
/** Available keychains policies. */
declare class NJSKeychainEngines
{
}
/** Class of constants representing the engines to rely on for synchronization. */
declare class NJSSynchronizerEngines
{
}
/** Available synchronization mechanisms. */
declare class NJSSynchronizationEngines
{
}
/** Default values you might want to use if you don’t know what values you should use. */
declare class NJSConfigurationDefaults
{
}
/** Overall configuration. */
declare class NJSConfiguration
{
}
/** Configuration of wallet pools. */
declare class NJSPoolConfiguration
{
}
/** Wrapper class around errors. */
declare class NJSDatabaseError
{
    /**
     * Get a human readable error message.
     * @return The error message.
     */
    declare function getMessage(): string;
}
/** A wrapper around SQL blob type. BLOB (Binary Large Object) is a builtin SQL type to store bytes. */
declare class NJSDatabaseBlob
{
    /**
     * Reads bytes from the blob at the given offset and of the a given length and return them in a byte array.
     * @param offset Start to read bytes from the blob at offset value.
     * @param length Maximum number of byte read from the blob
     */
    declare function read(offset: number, length: number): Object;
    /**
     * Write the given bytes at the given offset in the BLOB.
     * @return The number of written bytes
     */
    declare function write(offset: number, data: Object): number;
    /**
     * Append the given bytes to the BLOB.
     * @param The data to append to the BLOB
     * @return the number of bytes written
     */
    declare function append(data: Object): number;
    /**
     * Truncate the BLOB to the length given by the newLen parameter (in bytes).
     * @param newLen The final size of the BLOB
     * @return The number of byte truncated
     */
    declare function trim(newLen: number): number;
    /**
     * Get the size of the BLOB.
     * @return the size of the BLOB in bytes.
     */
    declare function size(): number;
}
/** An object holding metadata information about a single SQL column (type, name...). */
declare class NJSDatabaseColumn
{
    /**
     * Get the type of the underlying SQL value.
     * @return The type of th
     */
    declare function getType(): DatabaseValueType;
    declare function getName(): string;
}
/**
 * A table of data representing a database query result, which is usually generated by executing a statement that queries the database.
 * DatabaseResultRow instances are not expected to live once DatabaseResultSet::next has been called on its parent result set.
 */
declare class NJSDatabaseResultRow
{
    /**
     * Check if the value is NULL at the given position.
     * @return true if the value is NULL, false otherwise.
     */
    declare function isNullAtPos(pos: number): boolean;
    /**
     * Get the column name at the given position.
     * @return the column name.
     */
    declare function getColumnName(pos: number): string;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getShortByPos(pos: number): number;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getIntByPos(pos: number): number;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getFloatByPos(pos: number): number;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getDoubleByPos(pos: number): number;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getLongByPos(pos: number): number;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getStringByPos(pos: number): string;
    /**
     * Get the value at the given position. The underneath value has to be an 16bit integer otherwise this call will fail.
     * @return the value at the given position.
     */
    declare function getBlobByPos(pos: number): NJSDatabaseBlob;
}
/**
 * ResultSet is a cursor over a query result. It allows user to iterate through query rows. When you start iterating through
 * result the cursor is placed before the first element of the set.
 */
declare class NJSDatabaseResultSet
{
    /**
     * Retrieve the current row pointed by the DatabaseResultSet. Return null if there is no row to retrieve.
     * @return The current row
     */
    declare function getRow(): NJSDatabaseResultRow;
    /** Get the number of rows updated by the query (UPDATE, INSERT, DELETE...) */
    declare function getUpdateCount(): number;
    /**
     * Returns true if the result set has at least one remaining row to get.
     * @return true if the result set has at least one remaining row to get, false otherwise.
     */
    declare function hasNext(): boolean;
    /**
     * Returns the number of remaining rows before the result set needs to load more rows
     * @return The number of remaining rows before the result set needs to load more rows.
     */
    declare function available(): number;
    /**
     * Internally move the result set to the next available row. This method may fail if there is no further row to fetch.
     * @return Return a result set pointing to the next row.
     */
    declare function next();
    /** Close the result set. */
    declare function close();
    /** Get the last error that occured on the database. */
    declare function getError(): NJSDatabaseError;
}
/**
 * A wrapper object around prepared SQL statements. lib-ledger-core will use placeholders when it needs to pass
 * parameters to a query. It will then  bind each parameter at a given position to a given value.
 */
declare class NJSDatabaseStatement
{
    /**
     * Bind the designated parameter to the given 16bit integer value.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindShort(pos: number, value: number);
    /**
     * Bind the designated parameter to the given 32bit integer value.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindInt(pos: number, value: number);
    /**
     * Bind the designated parameter to the given 64bit integer value.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindLong(pos: number, value: number);
    /**
     * Bind the designated parameter to the given 32bit floating point number value.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindFloat(pos: number, value: number);
    /**
     * Bind the designated parameter to the given 64bit floating point number value.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindDouble(pos: number, value: number);
    /**
     * Bind the designated parameter to the given string.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindString(pos: number, value: string);
    /**
     * Bind the designated parameter to the given BLOB.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindBlob(pos: number, value: NJSDatabaseBlob);
    /**
     * Bind the designated parameter to the NULL value in SQL.
     * @param pos The position of the parameter in the query
     * @param value The value to bind
     */
    declare function bindNull(pos: number);
    /**
     * Describe the metadata attached to the designated column (e.g. data type, column name...)
     * @return Column metadata descriptor
     */
    declare function describeColumn(colNum: number): NJSDatabaseColumn;
    /**
     * Get the number of column that will be available into the result row (e.g. "SELECT name, age FROM USERS"
     * would return 2).
     * @return The number of the columns available in the result
     */
    declare function getColumnCount(): number;
    /**
     * Execute the statement with the past bound values.
     * @return The result of the execution of the statement on the database.
     */
    declare function execute(): NJSDatabaseResultSet;
    /** Reset all bindings. This call is used before reusing a statement instance in order to repeat it multiple time. */
    declare function reset();
    /** Close the statement and release all allocated resources. The statement shouldn't be used after this call. */
    declare function close();
}
/**
 * An active connection to a database. This API is fully synchronous and all objects created by this interface need to
 * return synchronously. A connection is used to prepare statements, managing transactions and creating abstractions of
 * database objects.
 */
declare class NJSDatabaseConnection
{
    /**
     * Prepare a statement object using the given SQL query. The statement object will then be responsible of executing
     * the query and handle results. Statement objects may be reused over time if their `repeatable` flag is set to true.
     * @param query A SQL query to execute (e.g. "SELECT * FROM users WHERE name = 'Joe'")
     * @param repeatable A flag to indicate whether or not the statement is repeatable
     */
    declare function prepareStatement(query: string, repeatable: boolean): NJSDatabaseStatement;
    /** Begin a SQL transaction on this connection. */
    declare function begin();
    /** End the current transaction and rollback all changes that occurred between the call of `begin` and `rollback`. */
    declare function rollback();
    /** End the current transaction and persist all changes that occurred between the call of `begin` and `commit`. */
    declare function commit();
    /** Close the current connection. After this call the connection should never be called again. */
    declare function close();
    /**
     * Create a new empty blob.
     * @return An empty blob
     */
    declare function newBlob(): NJSDatabaseBlob;
    /** Check whether the connection is still alive. */
    declare function isAlive(): boolean;
}
/** A pool of connections to a single database. */
declare class NJSDatabaseConnectionPool
{
    /**
     * Get a connection to the database. This method won't be called more than the engine pool size return
     * by DatabaseEngine::getPoolSize.
     * @return A connection to the database
     */
    declare function getConnection(): NJSDatabaseConnection;
}
/** An interface to implement a custom SQL backend on host side instead of using a native backend. */
declare class NJSDatabaseEngine
{
    /**
     * Open a connection to a database using the given database name.
     * @params databaseName The name of the database to open
     * @return A connection pool to the given database
     */
    declare function connect(databaseName: string): NJSDatabaseConnectionPool;
    /**
     * Get the maximum number of concurrent connection on a single database.
     * @return the maximum number of concurrent connection that the engine is able to open on a single database.
     */
    declare function getPoolSize(): number;
}
/**Class representing a database backend. */
declare class NJSDatabaseBackend
{
    /**
     * Get the maximum number of concurrent connection that the backend is able to open on a single database.
     * @return the size of the connection pool.
     */
    declare function getConnectionPoolSize(): number;
    /**
     * Enable or disable query logging. By default logging is disabled. Query logging will record every SQL query in log streams.
     * @return this database backend (to chain configuration calls)
     */
    declare function enableQueryLogging(enable: boolean): NJSDatabaseBackend;
    /**
     * Return true if query logging is enabled.
     * @return trye if query logging is enabled, false otherwise.
     */
    declare function isLoggingEnabled(): boolean;
    /**
     * Create an instance of SQLite3 database.
     * @return DatabaseBackend object
     */
    static declare function getSqlite3Backend(): NJSDatabaseBackend;
    /**
     * Create an instance of PostgreSQL database.
     * @return DatabaseBackend object
     */
    static declare function getPostgreSQLBackend(connectionPoolSize: number): NJSDatabaseBackend;
    /** Create a database backend instance from the given DatabaseEngine implementation. */
    static declare function createBackendFromEngine(engine: NJSDatabaseEngine): NJSDatabaseBackend;
}
/** Class to generate random numbers. */
declare class NJSRandomNumberGenerator
{
    /**
     * Generates random bytes.
     * @params size number of bytes to generate
     * @return 'size' random bytes
     */
    declare function getRandomBytes(size: number): Object;
    /**
     * Generates random 32 bits integer.
     * @return random 32 bits integer
     */
    declare function getRandomInt(): number;
    /**
     * Generates random 64 bits integer.
     * @return random 64 bits integer
     */
    declare function getRandomLong(): number;
    /**
     * Generates random byte.
     * @return random byte
     */
    declare function getRandomByte(): number;
}
declare class NJSEthereumPublicKeyProvider
{
}
/** ERC20-like accounts class. */
declare class NJSERC20LikeAccount
{
    /** Get an ERC20 token. */
    declare function getToken(): ERC20Token;
    /** Get the address of this ERC20 account. */
    declare function getAddress(): string;
    /** Get the current balance of this ERC20 account. */
    declare function getBalance(callback: NJSBigIntCallback);
    /**
     * Get the balance history of this ERC20 account from a starting date (included) to an ending
     * date (included).
     */
    declare function getBalanceHistoryFor(start: Date, end: Date, period: TimePeriod): Array<NJSBigInt>;
    /** Get the list of operations performed on this ERC20 account. */
    declare function getOperations(): Array<NJSERC20LikeOperation>;
    /** Retrieve raw data concerning a transaction of a given amount to a given address. */
    declare function getTransferToAddressData(amount: NJSBigInt, address: string, data: NJSBinaryCallback);
    declare function queryOperations(): NJSOperationQuery;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSBinaryCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Object, error: ?Error);
}
/** Class representing a Ethereum transaction. */
declare class NJSERC20LikeOperation
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get the nonce of the transaction : sequence number issued by originating EOA. */
    declare function getNonce(): NJSBigInt;
    /** Get Gas price (in wei). */
    declare function getGasPrice(): NJSBigInt;
    /** Get start gas (in wei) : maximum amount of gas the originator is willing to pay. */
    declare function getGasLimit(): NJSBigInt;
    /** Used gas (in wei) : used gas during this transaction: */
    declare function getUsedGas(): NJSBigInt;
    /** Get source ETH address. */
    declare function getSender(): string;
    /** Get destination ETH address. */
    declare function getReceiver(): string;
    /** Get amount of ether to send. */
    declare function getValue(): NJSBigInt;
    /** Get binary data payload. */
    declare function getData(): Object;
    /**
     * Get the time when the transaction was issued or the time of the block including this
     * this transaction.
     */
    declare function getTime(): Date;
    /** Get operation type : whether it is a SEND or RECEIVE. */
    declare function getOperationType(): OperationType;
    /** Get opration status : pending or confirmed. */
    declare function getStatus(): number;
    /**
     * Get block height on which operation was included.
     * @return Optional 64-bit integer, height of block in which operation was validated
     */
    declare function getBlockHeight(): ?number;
}
/** A callback called when an Ethereum-like wallet is available after issuing a get command. */
declare class NJSGetEthreumLikeWalletCallback
{
    declare function onSuccess(wallet: NJSEthereumLikeWallet, isCreated: boolean);
    declare function onError(error: Error);
}
/** An Ethereum-like wallet. */
declare class NJSEthereumLikeWallet
{
}
/** Class representing a Ethereum transaction. */
declare class NJSEthereumLikeTransaction
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get the nonce of the transaction : sequence number issued by originating EOA. */
    declare function getNonce(): number;
    /** Get Gas price (in wei). */
    declare function getGasPrice(): NJSAmount;
    /** Get start gas (in wei) : maximum amount of gas the originator is willing to pay. */
    declare function getGasLimit(): NJSAmount;
    /** Effective used gas. */
    declare function getGasUsed(): NJSAmount;
    /** Get destination ETH address. */
    declare function getReceiver(): NJSEthereumLikeAddress;
    /** Get ETH sender address. */
    declare function getSender(): NJSEthereumLikeAddress;
    /** Get amount of ether to send. */
    declare function getValue(): NJSAmount;
    /** Get binary data payload. */
    declare function getData(): ?Object;
    /** Get status of transaction: equals to 1 if succeeded, 0 otherwise */
    declare function getStatus(): number;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Set signature of transaction, when a signature is set serialize method gives back serialized Tx. */
    declare function setSignature(vSignature: Object, rSignature: Object, sSignature: Object);
    declare function setDERSignature(signature: Object);
    declare function setVSignature(vSignature: Object);
    /**
     * Get the time when the transaction was issued or the time of the block including this
     * transaction.
     */
    declare function getDate(): Date;
    /** Get block to which transaction belongs (was mined in). */
    declare function getBlock(): ?NJSEthereumLikeBlock;
}
/** Class representing an Ethereum internal transaction. */
declare class NJSInternalTransaction
{
    /** Get start gas (in wei) : maximum amount of gas the originator is willing to pay. */
    declare function getGasLimit(): NJSBigInt;
    /** Used gas (in wei) : used gas during this transaction: */
    declare function getUsedGas(): NJSBigInt;
    /** Get source ETH address. */
    declare function getSender(): string;
    /** Get destination ETH address. */
    declare function getReceiver(): string;
    /** Get amount of ether to send. */
    declare function getValue(): NJSBigInt;
    /** Get binary data payload. */
    declare function getData(): Object;
    /** Get operation type : whether it is a SEND or RECEIVE. */
    declare function getOperationType(): OperationType;
}
/** Class representing a Ethereum Operation. */
declare class NJSEthereumLikeOperation
{
    /**
     * Get operation's transaction.
     * @return EthereumLikeTransaction object
     */
    declare function getTransaction(): NJSEthereumLikeTransaction;
    /** Get all actions triggered by this transaction */
    declare function getInternalTransactions(): Array<NJSInternalTransaction>;
}
/** Class representing Ethereum block. */
declare class NJSEthereumLikeBlock
{
    /**
     * Hash of block.
     * @return string representing hash of this block
     */
    declare function getHash(): string;
    /**
     * Height of block in blockchain.
     * @return 64 bits integer, height of block
     */
    declare function getHeight(): number;
    /**
     * Timestamp when block was mined.
     * @return Date object, date when block was appended to blockchain
     */
    declare function getTime(): Date;
}
/**
 * Builder for transactions on the Ethereum blockchain.
 *
 * Use this interface when you want to build a transaction step by step.
 */
declare class NJSEthereumLikeTransactionBuilder
{
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSEthereumLikeTransactionBuilder;
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function wipeToAddress(address: string): NJSEthereumLikeTransactionBuilder;
    /**
     * Set gas price (in wei) the originator is willing to pay.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setGasPrice(gasPrice: NJSAmount): NJSEthereumLikeTransactionBuilder;
    /**
     * Set gas limit (in wei) the originator is not willing to exceed.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setGasLimit(gasLimit: NJSAmount): NJSEthereumLikeTransactionBuilder;
    /** Set input data the originator wants to embed in transaction. */
    declare function setInputData(data: Object): NJSEthereumLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSEthereumLikeTransactionCallback);
    /**
     * Create a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSEthereumLikeTransactionBuilder;
    /** Reset the current instance to its initial state */
    declare function reset();
    /** Create an unsigned transaction for the Ethereum blockchain out of a raw binary. */
    static declare function parseRawUnsignedTransaction(currency: Currency, rawTransaction: Object): NJSEthereumLikeTransaction;
    /** Create a signed transaction for the Ethereum blockchain out of a raw binary. */
    static declare function parseRawSignedTransaction(currency: Currency, rawTransaction: Object): NJSEthereumLikeTransaction;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSEthereumLikeTransactionCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSEthereumLikeTransaction, error: ?Error);
}
/** Class representing a Ethereum account. */
declare class NJSEthereumLikeAccount
{
    /** Send a raw (binary) transaction on the Ethereum blockchain. */
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    /** Send a transaction on the Ethereum blockchain. */
    declare function broadcastTransaction(transaction: NJSEthereumLikeTransaction, callback: NJSStringCallback);
    /** Get a builder object to construct transactions. */
    declare function buildTransaction(): NJSEthereumLikeTransactionBuilder;
    /** Get the list of ERC20 accounts associated with this Ethereum account. */
    declare function getERC20Accounts(): Array<NJSERC20LikeAccount>;
    /**
     * Get gas price from network
     * Note: it would have been better to have this method on EthereumLikeWallet
     * but since EthereumLikeWallet is not used anywhere, it's better to keep all
     * specific methods under the same specific class so it will be easy to segratate
     * when the right time comes !
     */
    declare function getGasPrice(callback: NJSBigIntCallback);
    /**
     * Get estimated gas limit to set so the transaction will succeed
     * The passed address could be EOA or contract
     * This estimation is based on X last incoming txs (to address) that succeeded
     * Note: same note as above
     */
    declare function getEstimatedGasLimit(address: string, callback: NJSBigIntCallback);
    /**
     * Get estimated gas limit to set so the transaction will succeed
     * The passed address could be EOA or contract
     * This estimation is based on a dry-run on the node, and it will fail if the request is ill-formed
     * Note: same note as above
     */
    declare function getDryRunGasLimit(address: string, request: EthereumGasLimitRequest, callback: NJSBigIntCallback);
    /**
     * Get balance of ERC20 token
     * The passed address is an ERC20 account
     * Note: same note as above
     */
    declare function getERC20Balance(erc20Address: string, callback: NJSBigIntCallback);
    /**
     * Get balance of ERC20 tokens
     * The passed addresses are ERC20 accounts
     * Note: same note as above
     */
    declare function getERC20Balances(erc20Addresses: Array<string>, callback: NJSBigIntListCallback);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSBigIntListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSBigInt>, error: ?Error);
}
declare class NJSBitcoinLikeScriptChunk
{
    declare function isOperator(): boolean;
    declare function isPushedData(): boolean;
    declare function getOperator(): ?BitcoinLikeOperator;
    declare function getPushedData(): ?Object;
    declare function next(): NJSBitcoinLikeScriptChunk;
    declare function hasNext(): boolean;
}
/** A general purpose script. */
declare class NJSBitcoinLikeScript
{
    /**
     * Get the head of the script. Scripts are organized by chunks, so you get an iterator-like
     * interface.
     */
    declare function head(): NJSBitcoinLikeScriptChunk;
    /** Turn the script into a string representation. */
    declare function toString(): string;
    /** Parse data into a script. */
    static declare function parse(data: Object): NJSBitcoinLikeScript;
}
/** Helper class for manipulating Tezos like addresses. */
declare class NJSTezosLikeAddress
{
    /**
     * Gets the version of the address.
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address.
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): TezosLikeNetworkParameters;
    /**
     * Encodes to Base58.
     * @return The Base58 encoding
     */
    declare function toBase58(): string;
}
/** The xPUB definition for Tezos. */
declare class NJSTezosLikeExtendedPublicKey
{
    /** Derive an address from an xPUB and a path. */
    declare function derive(path: string): NJSTezosLikeAddress;
    /** Derive a public key from an xPUB and a path. */
    declare function derivePublicKey(path: string): Object;
    /** Derive a shorten version of a public key (SHA256 + RIPEMD160) from an xPUB and a path. */
    declare function deriveHash160(path: string): Object;
    /** Get the xPUB in base 58. */
    declare function toBase58(): string;
    /** Get the root path of the xPUB. */
    declare function getRootPath(): string;
}
/** Helper class for manipulating Ripple like addresses */
declare class NJSRippleLikeAddress
{
    /**
     * Gets the version of the address
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): RippleLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): string;
}
declare class NJSRippleLikeExtendedPublicKey
{
    declare function derive(path: string): NJSRippleLikeAddress;
    declare function derivePublicKey(path: string): Object;
    declare function deriveHash160(path: string): Object;
    declare function toBase58(): string;
    declare function getRootPath(): string;
}
/** Helper class for manipulating Ethereum like addresses. */
declare class NJSEthereumLikeAddress
{
    /**
     * Gets the version of the address.
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw keccak hash of the public key (truncated to 20 bytes).
     * @return The 20 bytes of the public key keccak hash
     */
    declare function getKeccakHash(): Object;
    /**
     * Gets the network parameters used for serializing the address.
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): EthereumLikeNetworkParameters;
    /**
     * Encodes keccak with respect to EIP55.
     * @return The EIP55 encoding
     */
    declare function toEIP55(): string;
}
/** The xPUB definition for Ethereum. */
declare class NJSEthereumLikeExtendedPublicKey
{
    /** Derive an address from an xPUB and a path. */
    declare function derive(path: string): NJSEthereumLikeAddress;
    /** Derive a public key from an xPUB and a path. */
    declare function derivePublicKey(path: string): Object;
    /** Derive a shorten version of a public key (SHA256 + RIPEMD160) from an xPUB and a path. */
    declare function deriveHash160(path: string): Object;
    /** Get the xPUB in base 58. */
    declare function toBase58(): string;
    /** Get the root path of the xPUB. */
    declare function getRootPath(): string;
}
/** Helper class for manipulating Bitcoin like addresses */
declare class NJSBitcoinLikeAddress
{
    /**
     * Gets the version of the address (P2SH or P2PKH)
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): BitcoinLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): string;
    /**
     * Get the Bech32 encoded address (with respect to BIP173)
     * @return The Bech32 encoded address
     */
    declare function toBech32(): string;
    /**
     * Serializes the hash160 to a payment uri (i.e bitcoin:16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM)
     * @return A payment uri to this address
     * toPaymentUri(): string;
     * Checks if the given address is a P2SH address
     * @return True if the keychain engine is P2SH
     */
    declare function isP2SH(): boolean;
    /**
     * Checks if the given address is a P2PKH address
     * @return if the keychain engine is P2PKH
     */
    declare function isP2PKH(): boolean;
    /**
     * Checks if the given address is a P2WSH address
     * @return True if the keychain engine is P2WSH
     */
    declare function isP2WSH(): boolean;
    /**
     * Checks if the given address is a P2WPKH address
     * @return True if the keychain engine is P2WPKH
     */
    declare function isP2WPKH(): boolean;
}
/** The xPUB definition for Bitcoin. */
declare class NJSBitcoinLikeExtendedPublicKey
{
    /** Derive an address from an xPUB and a path. */
    declare function derive(path: string): NJSBitcoinLikeAddress;
    /** Derive a public key from an xPUB and a path. */
    declare function derivePublicKey(path: string): Object;
    /** Derive a shorten version of a public key (SHA256 + RIPEMD160) from an xPUB and a path. */
    declare function deriveHash160(path: string): Object;
    /** Get the xPUB in base 58. */
    declare function toBase58(): string;
    /** Get the root path of the xPUB. */
    declare function getRootPath(): string;
}
/** Class representing amount of transaction, output, inputs… */
declare class NJSAmount
{
    /**
     * Get amount as a BigInt.
     * @return BigInt
     */
    declare function toBigInt(): NJSBigInt;
    /**
     * Get currency in which amount was computed.
     * @return Currency object
     */
    declare function getCurrency(): Currency;
    /**
     * Get currency unit in which amount was computed.
     * @return CurrencyUnit object
     */
    declare function getUnit(): CurrencyUnit;
    /**
     * Convert amount in another currency unit.
     * @param CurrencyUnit object, target currency unit
     * @return Amount object, amount in target currency unit
     */
    declare function toUnit(unit: CurrencyUnit): NJSAmount;
    /** Get an amount that is equal to the given magnitude in the units system. */
    declare function toMagnitude(magnitude: number): NJSAmount;
    /**
     * Get amount as string
     * @return string
     */
    declare function toString(): string;
    /**
     * Get amount as long
     * @return 64 bits integer
     */
    declare function toLong(): number;
    /**
     * Get amount as double
     * @return double
     */
    declare function toDouble(): number;
    /** Format an amount with a locale and some formatting rules. */
    declare function format(locale: Locale, rules: ?FormatRules): string;
    /** Transform an hexadecimal string into an amount (expressed in the given currency). */
    static declare function fromHex(currency: Currency, hex: string): NJSAmount;
    /** Transform a 64-bit number into an amount (expressed in the given currency). */
    static declare function fromLong(currency: Currency, value: number): NJSAmount;
}
/**
 * Interface for accessing and modifying custom preferences. Preferences are key - value data which will be persisted to
 * the filesystem. They can be local or stored with the Ledger API backend (encrypted by a user secret). This can be used to
 * attach application data to the libledger-core modules (i.e. a wallet pool, a wallet, an account, an operation). This interface
 * is highly inspired by Android SharedPreferences.
 */
declare class NJSPreferences
{
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getString(key: string, fallbackValue: string): string;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getInt(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getLong(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getBoolean(key: string, fallbackValue: boolean): boolean;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getStringArray(key: string, fallbackValue: Array<string>): Array<string>;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getData(key: string, fallbackValue: Object): Object;
    /**
     * Checks whether the Preferences contains the given key.
     * @return true the preferences contains the key, false otherwise.
     */
    declare function contains(key: string): boolean;
    /**
     * Get a preferences editor in order to add/modify/remove data.
     * @return An interface for editting preferences.
     */
    declare function edit(): NJSPreferencesEditor;
}
/** Interface for editting Preferences. All changes to the editor are persisted to the disk only when comitted. */
declare class NJSPreferencesEditor
{
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putString(key: string, value: string): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putInt(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putLong(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putBoolean(key: string, value: boolean): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putStringArray(key: string, value: Array<string>): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putData(key: string, value: Object): NJSPreferencesEditor;
    /**
     * Removes the data associated with the given key.
     * @param key The key to remove from the Preferences
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function remove(key: string): NJSPreferencesEditor;
    /** Persists the changes to the Preferences. */
    declare function commit();
    /** Clear all preferences. */
    declare function clear();
}
/** Class of constants to set Bitcoin like wallet configurations. */
declare class NJSBitcoinLikeWalletConfiguration
{
}
/** Class representing Bitcoin inputs. */
declare class NJSBitcoinLikeInput
{
    /** Returns the address of the input (if an address can be computed). */
    declare function getAddress(): ?string;
    /**
     * Returns the public associated with the address. This value can be NULL if you are building a transaction with an
     * address which does not belong to your wallet.
     */
    declare function getPublicKeys(): Array<Object>;
    /** Returns the derivation path of this input if the address is owned by the wallet. */
    declare function getDerivationPath(): Array<NJSDerivationPath>;
    /**
     * Returns the value of the amount. Depending on the backend this value may not exist if the input is not owned by
     * the wallet.
     */
    declare function getValue(): ?NJSAmount;
    /**
     * Get the transaction hash of the output spent by this input. The result can be NULL if the output is not owned by
     * the wallet.
     */
    declare function getPreviousTxHash(): ?string;
    /**
     * Check whether input is for a coinbase.
     * @return Boolean, true if input belongs to coinbase transaction (reward for mining a block)
     */
    declare function isCoinbase(): boolean;
    /**
     * Stored data cointained in coinbase.
     * @return Optional String
     */
    declare function getCoinbase(): ?string;
    /**
     * Get output index, it identifies which UTXO from tht transaction to spend.
     * @return Optional 32 bits integer, index of previous transaction
     */
    declare function getPreviousOutputIndex(): ?number;
    /**
     * Retrieve the output spent by this input. Depending on the implementation this method may
     * use a lock to fetch data from a database. Therefore it may have poor performance, use with
     * caution.
     * @return The output spent by this input.
     */
    declare function getPreviousOuput(): NJSBitcoinLikeOutput;
    /** Get ScriptSig of this input. The scriptsig is the first half of a script necessary to spend a previous output. */
    declare function getScriptSig(): Object;
    /** Parse the script sig to a [[BitcoinLikeScript]]. */
    declare function parseScriptSig(): NJSBitcoinLikeScript;
    /**
     * Set the ScriptS to the given value.
     * @param scriptSig The ScriptSig to use for this input
     */
    declare function setScriptSig(scriptSig: Object);
    /** Push data to the end of the current ScriptSig. */
    declare function pushToScriptSig(data: Object);
    /** Set the sequence number of this input. */
    declare function setSequence(sequence: number);
    /** Get the sequence number of this input. */
    declare function getSequence(): number;
    /** Get the previous transaction associated with the input. */
    declare function getPreviousTransaction(callback: NJSBinaryCallback);
    /** Easy way to set the P2PKH script signature. Shorthand for input.pushToScriptSig(input.getPublicKeys()[0], signature). */
    declare function setP2PKHSigScript(signature: Object);
}
/** Class representing Bitcoin outputs. */
declare class NJSBitcoinLikeOutput
{
    /**
     * Get transaction hash in which output was 'created'.
     * @return String, transaction hash containing output
     */
    declare function getTransactionHash(): string;
    /**
     * Get index of output in list of all outputs contained in same transaction.
     * @return 32 bits integer, index of output
     */
    declare function getOutputIndex(): number;
    /**
     * Get amount of output.
     * @return Amount object, amount of output
     */
    declare function getValue(): NJSAmount;
    /**
     * Get script (witness script) cryptographic puzzle that determines the conditions to spend the output.
     * @return in Bytes (variable size depending on type of script P2PKH, P2SH), locking script to spend UTXO
     */
    declare function getScript(): Object;
    declare function parseScript(): NJSBitcoinLikeScript;
    /**
     * Get address that spent the output.
     * @return Optional String, address that spent
     */
    declare function getAddress(): ?string;
    declare function getDerivationPath(): ?NJSDerivationPath;
    declare function getBlockHeight(): ?number;
}
/** Class representing Bitcoin block */
declare class NJSBitcoinLikeBlock
{
    /**
     * Hash of block.
     * @return string representing hash of this block
     */
    declare function getHash(): string;
    /**
     * Height of block in blockchain.
     * @return 64 bits integer, height of block
     */
    declare function getHeight(): number;
    /**
     * Timestamp when block was mined.
     * @return Date object, date when block was appended to blockchain
     */
    declare function getTime(): Date;
}
/** Class representing a Bitcoin transaction. */
declare class NJSBitcoinLikeTransaction
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get the input of the transaction. */
    declare function getInputs(): Array<NJSBitcoinLikeInput>;
    /** Get the output of the transaction. */
    declare function getOutputs(): Array<NJSBitcoinLikeOutput>;
    /** Get the block in which the transaction is inserted if the transaction is confirmed. */
    declare function getBlock(): ?NJSBitcoinLikeBlock;
    /** Get the lock time of the transaction. */
    declare function getLockTime(): number;
    /** Get the amount of fees of the transaction. */
    declare function getFees(): NJSAmount;
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction.
     */
    declare function getTime(): Date;
    /** Get the timestamps serialized in the raw transaction if the underlying currency handles it. */
    declare function getTimestamp(): ?number;
    /** Get Transaction version. */
    declare function getVersion(): number;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Serialize outputs of the raw transaction into a byte array using the bitcoin transaction format. */
    declare function serializeOutputs(): Object;
    /** Get the witness if the underlying transaction is a segwit transaction. */
    declare function getWitness(): ?Object;
    /**
     * Estimate the size of the raw transaction in bytes. This method returns a minimum estimated size and a maximum estimated
     * size.
     */
    declare function getEstimatedSize(): EstimatedSize;
    /**
     * Sign all inputs for given transaction. 
     * Build DER encoded signature from RSV data.
     * @return SIGNING_SUCCEED if succeed case else refers to BitcoinLikeSignatureState enumeration
     */
    declare function setSignatures(signatures: Array<BitcoinLikeSignature>, override: boolean): BitcoinLikeSignatureState;
    /**
     * Sign all inputs for given transaction. 
     * @return SIGNING_SUCCEED if succeed case else refers to BitcoinLikeSignatureState enumeration
     */
    declare function setDERSignatures(signatures: Array<Object>, override: boolean): BitcoinLikeSignatureState;
}
/** Class representing a Bitcoin Operation. */
declare class NJSBitcoinLikeOperation
{
    /**
     * Get operation's transaction.
     * @return BitcoinLikeTransaction object
     */
    declare function getTransaction(): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeTransactionBuilder
{
    /**
     * Add the given input to the final transaction.
     * @param transactionhash The hash of the transaction in where the UTXO can be located.
     * @params index Index of the UTXO in the previous transaction
     * @params sequence Sequence number to add at the end of the input serialization. This can be used for RBF transaction
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addInput(transactionHash: string, index: number, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Add the given output to the final transaction.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addOutput(amount: NJSAmount, script: NJSBitcoinLikeScript): NJSBitcoinLikeTransactionBuilder;
    /**
     * If needed the transaction will send its change to the given path. It is possible to add multiple change path.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addChangePath(path: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Exclude UTXO from the coin selection (alias UTXO picking). You can call this method multiple times to exclude multiple
     * UTXO.
     * @param transactionHash The hash of the transaction in which this UTXO can be found.
     * @param outputIndex The position of the output in the previous transaction,
     * @return A reference on the same builder in order to chain calls.
     */
    declare function excludeUtxo(transactionHash: string, outputIndex: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the the number of change addresses in the transaction builder.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setNumberOfChangeAddresses(count: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the maximum amount per change output. By default there is no max amount.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMaxAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the minimum amount per change output. By default this value is the dust value of the currency.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMinAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the UTXO picking strategy (see [[BitcoinLikePickingStrategy]]).
     * @param strategy The strategy to adopt in order to select which input to use in the transaction.
     * @param sequence The sequence value serialized at the end of the raw transaction. If you don't know what to put here
     * just use 0xFFFFFF
     * @return A reference on the same builder in order to chain calls.
     */
    declare function pickInputs(strategy: BitcoinLikePickingStrategy, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function wipeToAddress(address: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the amount of fees per byte (of the raw transaction).
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setFeesPerByte(fees: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSBitcoinLikeTransactionCallback);
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSBitcoinLikeTransactionBuilder;
    /** Reset the current instance to its initial state. */
    declare function reset();
    /**
     * Parsing unsigned transaction.
     * parsing a tx might change depending on block height we are on (if an update is effective starting from a given hight)
     */
    static declare function parseRawUnsignedTransaction(currency: Currency, rawTransaction: Object, currentBlockHeight: ?number): NJSBitcoinLikeTransaction;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSBitcoinLikeTransactionCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSBitcoinLikeTransaction, error: ?Error);
}
/** Class representing a Bitcoin account. */
declare class NJSBitcoinLikeAccount
{
    /**
     * Get UTXOs of account in a given range.
     * @param from, integer, lower bound for account's UTXO's index
     * @param to, integer, upper bound for account's UTXO's index
     * @param callback, ListCallback object which returns a list of BitcoinLikeOutput if getUTXO succeed
     */
    declare function getUTXO(from: number, to: number, callback: NJSBitcoinLikeOutputListCallback);
    /**
     * Get UTXOs count of account.
     * @param callback, Callback object which returns number of UTXO owned by this account
     */
    declare function getUTXOCount(callback: NJSI32Callback);
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    declare function broadcastTransaction(transaction: NJSBitcoinLikeTransaction, callback: NJSStringCallback);
    declare function buildTransaction(partial: ?boolean): NJSBitcoinLikeTransactionBuilder;
    /**
     * Get fees from network, fees are ordered in descending order (i.e. fastest to slowest confirmation)
     * Note: it would have been better to have this method on BitcoinLikeWallet
     * but since BitcoinLikeWallet is not used anywhere, it's better to keep all
     * specific methods under the same specific class so it will be easy to segratate
     * when the right time comes !
     */
    declare function getFees(callback: NJSBigIntListCallback);
    /**
     * Get addresses given a range of indices
     * Note: this will return public and change addresses
     */
    declare function getAddresses(from: number, to: number, callback: NJSAddressListCallback);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSBitcoinLikeOutputListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSBitcoinLikeOutput>, error: ?Error);
}
/** A bitcoin-like wallet. */
declare class NJSBitcoinLikeWallet
{
}
/** Class respresenting a pool of wallets. */
declare class NJSWalletPool
{
    /**
     * Create a new instance of WalletPool object.
     * @param name, string, name of the wallet pool
     * @param password, string, password to lock wallet pool (empty string means no password)
     * @param http, HttpClient object, http client used for all calls made by wallet pool (and aggregated wallets)
     * @param webSocketClient, WebSocketClient object, socket through which wallet pool observe and get notified (explorer, DBs ...)
     * @param pathResolver, PathResolver Object, resolve paths to logs, databases, preferences ...
     * @param logPrinter, LogPrinter object, used to dump/log for debug purpose
     * @param dispatcher, ThreadDispatcher object, responsable of dispatching task through available threads
     * @param rng, RandomNumberGenerator object, needed for generating random numbers (for seeds, salts ...)
     * @param backend, DatabseBackend object, DB in which wallet pool store all required infos (created wallets, their options, their accounts ...)
     * @param configuration, DynamicObject object, desired configuration for this wallet pool
     * @return WalletPool object, instance of WalletPool
     */
    static declare function newInstance(name: string, password: string, httpClient: NJSHttpClient, webSocketClient: NJSWebSocketClient, pathResolver: NJSPathResolver, logPrinter: NJSLogPrinter, dispatcher: NJSThreadDispatcher, rng: NJSRandomNumberGenerator, backend: NJSDatabaseBackend, configuration: NJSDynamicObject): NJSWalletPool;
    /**
     * Return used logger to dump logs in defined log path by PathResolver.
     * @return Logger object
     */
    declare function getLogger(): NJSLogger;
    /**
     * Return the name of the wallet pool.
     * @return string
     */
    declare function getName(): string;
    /**
     * Return preferences of wallet pool (deduced from configuration).
     * @return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     * Return number of wallets instanciated under wallet pool.
     * @param callback, Callback object returns a 32 bits integer, count of wallets
     */
    declare function getWalletCount(callback: NJSI32Callback);
    /**
     * Get instanciated wallets having index in a given range.
     * @param from, 32 bits integer, lower bound of indices to pick
     * @param to, 32 bits integer, upper bound of indices to pick
     * @param callback, ListCallback object returns a list of Wallet objects
     */
    declare function getWallets(from: number, size: number, callback: NJSWalletListCallback);
    /**
     * Get wallet with a giver name.
     * @param name, string, name of wallet to look for
     * @param callback, Callback object returns a Wallet object
     */
    declare function getWallet(name: string, callback: NJSWalletCallback);
    /**
     * Update wallet configuration
     * @param name, string, name of wallet to update
     * @param configuration, DynamicObject object, configuration object with fields to update
     * @param callback, Callback object returns the error code, returns ErrorCode::FUTURE_WAS_SUCCESSFULL if everything is fine
     * > Note: other fields that are not passed in 'configuration' parameter
     * > that might have been created before remain intact
     */
    declare function updateWalletConfig(name: string, configuration: NJSDynamicObject, callback: NJSErrorCodeCallback);
    /**
     * Instanciate a new wallet under wallet pool.
     * @param name, string, name of newly created wallet
     * @param currency, Currency object, currency of the wallet
     * @param configuration, DynamicObject object, configuration of wallet (preferences)
     * @param callback, Callback object returning a Wallet object
     */
    declare function createWallet(name: string, currency: Currency, configuration: NJSDynamicObject, callback: NJSWalletCallback);
    /**
     * Return all supported currencies by wallet pool, at least one wallet support one of returned currencies.
     * @param callback, ListCallback object, returns a list of Currency objects
     */
    declare function getCurrencies(callback: NJSCurrencyListCallback);
    /**
     * Return currency of a specific wallet.
     * @param name, wallet's name to look for
     * @param callback, Callback object returning a Currency object
     */
    declare function getCurrency(name: string, callback: NJSCurrencyCallback);
    /**
     * Return last block of blockchain of a given currency (if it is supported by the wallet pool).
     * @param name, string, name of currency we are interested into getting it's blockchain's last block
     * @param callback, Callback object returns a Block object
     */
    declare function getLastBlock(currencyName: string, callback: NJSBlockCallback);
    /**
     * Get event bus (handler) through which wallet pool observe and gets notified (explorers, DBs ...).
     * @param EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     * Erase data (in user's DB) relative to wallet since given date.
     * @param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
    /**
     * Reset wallet pool.
     *
     * Resetting the wallet pool is an irreversible fresh reset of the whole wallet pool
     * and all of its created (sub-)objects (wallets, accounts, transactions, etc.). Please
     * consider a less destructive option before opting to use this. However, if you’re
     * looking for a way to end up as if you were in a “fresh install” situation, this is
     * the function to go to.
     *
     * Final warning: this function effectively swipes off everything. You’ve been warned.
     *
     * > Note: when calling that function, you must re-create a WalletPool as all objects
     * > got destroyed. Consider restarting / exiting your application right after calling
     * > that function. You are also highly advised to run that function on a code path
     * > that doesn’t include having lots of objects in memory.
     *
     * The return value is always true and doesn’t convey any useful information for now.
     */
    declare function freshResetAll(callback: NJSErrorCodeCallback);
    /**
     * Change Database password.
     *
     * Allow to change password of database holding all informations about
     * accounts, wallets, transactions etc. and the wallet pool preferences.
     *
     * WARNING: be careful to have no other instances of WalletPool using
     * same database / preferences.
     */
    declare function changePassword(oldPassword: string, newPassword: string, callback: NJSErrorCodeCallback);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSWalletListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSWallet>, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSWalletCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSWallet, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result as list of template type T. */
declare class NJSCurrencyListCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<Currency>, error: ?Error);
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSCurrencyCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Currency, error: ?Error);
}
/** Class representing a wallet pool builder (to instanciate a wallet pool). */
declare class NJSWalletPoolBuilder
{
    /**
     * Set http client to be used for wallet pool build.
     * @param client, HttpClient
     * @return WalletPoolBuilder object, instance with wallet pool http client set
     */
    declare function setHttpClient(client: NJSHttpClient): NJSWalletPoolBuilder;
    /**
     * Set web socket client, through which wallet pool will listen and get notified (by explorers, DBs...).
     * @param client, WebSocketClient object
     * @reutnr WalletPoolBuilder object, instance with wallet pool web socket client set
     */
    declare function setWebsocketClient(client: NJSWebSocketClient): NJSWalletPoolBuilder;
    /**
     * Set path resolver that will be used for wallet pool creation to resolve wallet pool's (DB's, logs, preferences ...) paths.
     * @param pathResolver, Pathresolver object
     * @param WalletPoolBuilder object, instance with wallet pool path resolver set
     */
    declare function setPathResolver(pathResolver: NJSPathResolver): NJSWalletPoolBuilder;
    /**
     * Set log printer that will be used for wallet pool creation to dump wallet pool's logs (for debug purposes).
     * @param printer, LogPrinter object
     * @param WalletPoolBuilder object, instance with wallet pool logger set
     */
    declare function setLogPrinter(printer: NJSLogPrinter): NJSWalletPoolBuilder;
    /**
     * Set thread dispatcher that will be used for wallet pool creation to dispatch wallet pool's tasks through different threads.
     * @param dispatcher, ThreadDispatcher object
     * @param WalletPoolBuilder object, instance with wallet pool thread dispatcher set
     */
    declare function setThreadDispatcher(dispatcher: NJSThreadDispatcher): NJSWalletPoolBuilder;
    /**
     * Set name that will be used for wallet pool creation.
     * @param name, string
     * @return WalletPoolBuilder object, instance with wallet pool name set
     */
    declare function setName(name: string): NJSWalletPoolBuilder;
    /**
     * Set password that will be used for wallet pool creation.
     * @param password, string
     * @return WalletPoolBuilder object, with wallet pool password set
     */
    declare function setPassword(password: string): NJSWalletPoolBuilder;
    /**
     * Set random number generator that will be used for wallet pool creation.
     * @param rng, RandomNumberGenerator object
     * @return WalletPoolBuilder object, with wallet pool random number generator set
     */
    declare function setRandomNumberGenerator(rng: NJSRandomNumberGenerator): NJSWalletPoolBuilder;
    /**
     * Set database that will be used for wallet pool creation, it will store all wallet pool's data (created wallets, accounts, preferences ...).
     * @param backend, DatabaseBackend object
     * @return WalletPoolBuilder object, with wallet pool database set
     */
    declare function setDatabaseBackend(backend: NJSDatabaseBackend): NJSWalletPoolBuilder;
    /**
     * Set configuration that will be used for wallet pool creation.
     * @param configuration, DynamicObject object
     * @return WalletPoolBuilder object, with wallet pool configuration set
     */
    declare function setConfiguration(configuration: NJSDynamicObject): NJSWalletPoolBuilder;
    /**
     * Create wallet pool.
     * @param callback, Callback object returning a WalletPool instance
     */
    declare function build(listener: NJSWalletPoolCallback);
    /**
     * Create an instance of the wallet pool builder.
     * @return WalletPoolBuilder object
     */
    static declare function createInstance(): NJSWalletPoolBuilder;
}
/** Callback triggered by main completed task, returning optional result of template type T. */
declare class NJSWalletPoolCallback
{
    /**
     * Method triggered when main task complete.
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSWalletPool, error: ?Error);
}
/** A connection to a Web Socket. */
declare class NJSWebSocketConnection
{
    /**
     * Callback to call upon successful connection.
     * @param connectionId, the ID of the Web Socket connection
     */
    declare function onConnect(connectionId: number);
    /** Callback to call upon successful disconnection. */
    declare function onClose();
    /**
     * Callback to call upon each incoming message.
     * @param data, the attached data to the input message
     */
    declare function onMessage(data: string);
    /**
     * Callback to call when a Web Socket error occurs.
     * @param code, the error code
     * @param message, a description of the reason of the error
     */
    declare function onError(code: ErrorCode, message: string);
    declare function getConnectionId(): number;
}
/** A connected client via Web Socket. */
declare class NJSWebSocketClient
{
    /**
     * Connect to a given URL via a Web Socket connection.
     * @param url, the URL to connect to
     * @connection, the Web Socket connection to use
     */
    declare function connect(url: string, connection: NJSWebSocketConnection);
    /**
     * Send a message to a given client.
     * @connection, the Web Socket connection to use
     * @data, the message to send
     */
    declare function send(connection: NJSWebSocketConnection, data: string);
    /**
     * Disconnect a client.
     * @connection, the Web Socket connection to use
     */
    declare function disconnect(connection: NJSWebSocketConnection);
}
/** Class representing an Http connection. */
declare class NJSHttpUrlConnection
{
    /**
     * Gets the HTTP response status code.
     * @return The HTTP response status code
     */
    declare function getStatusCode(): number;
    /**
     * Gets the HTTP response status text.
     * @return The HTTP response status text
     */
    declare function getStatusText(): string;
    /**
     * Gets the HTTP response headers.
     * @return The HTTP response headers
     */
    declare function getHeaders(): Map<string, string>;
    /**
     * Reads available HTTP response body. This method will be called multiple times until it returns a empty bytes array.
     * @returns A chunk of the body data wrapped into a HttpReadBodyResult (for error management)
     */
    declare function readBody(): HttpReadBodyResult;
}
/** Class representing an Http request. */
declare class NJSHttpRequest
{
    /**
     * Get method of request.
     * @return HttpMethod enum entry
     */
    declare function getMethod(): HttpMethod;
    /**
     * Get headers set in the request.
     * @return Map with key and value of type string
     */
    declare function getHeaders(): Map<string, string>;
    /**
     * Get body of request.
     * @return binary
     */
    declare function getBody(): Object;
    /**
     * Get Url of request.
     * @return string
     */
    declare function getUrl(): string;
    /**
     * Method called when reauest is completed.
     * @param response, Optional HttpUrlConnection object, response of request if succeed
     * @param error, optional Error structure, error returned in case of request failure
     */
    declare function complete(response: ?NJSHttpUrlConnection, error: ?Error);
}
/** Class representing the http client performing the http requests. */
declare class NJSHttpClient
{
    /**
     * Execute a giver Http request.
     * @param request, HttpRequest object, requestr to execute
     */
    declare function execute(request: NJSHttpRequest);
}
/** Immutable class representing a potentially very long number. */
declare class NJSBigInt
{
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    declare function add(i: NJSBigInt): NJSBigInt;
    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    declare function subtract(i: NJSBigInt): NJSBigInt;
    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    declare function multiply(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    declare function divide(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    declare function divideAndRemainder(i: NJSBigInt): Array<NJSBigInt>;
    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    declare function pow(exponent: number): NJSBigInt;
    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5").
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    declare function toDecimalString(precision: number, decimalSeparator: string, thousandSeparator: string): string;
    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    declare function toString(radix: number): string;
    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    declare function intValue(): number;
    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    declare function compare(i: NJSBigInt): number;
    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000").
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    static declare function fromDecimalString(s: string, precision: number, decimalSeparator: string): NJSBigInt;
    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    static declare function fromIntegerString(s: string, radix: number): NJSBigInt;
    /**
     * Creates a BigInt from a int64 value.
     * @param l The value to convert
     * @return The created BigInt
     */
    static declare function fromLong(l: number): NJSBigInt;
}
/**
 * Module used to resolve file paths. libledger-core has its own iternal representation of the file system that may not
 * be adapted for the runtime platform. All path given to the PathResolver are absolute.
 */
declare class NJSPathResolver
{
    /**
     * Resolves the path for a SQLite database file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveDatabasePath(path: string): string;
    /**
     * Resolves the path of a single log file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveLogFilePath(path: string): string;
    /**
     * Resolves the path for a json file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolvePreferencesPath(path: string): string;
}
/**
 *Class representing a runnable object
 *A runnable, needs a specific execution context (refer to ExecutionContext) to run
 */
declare class NJSRunnable
{
    /**Trigger runnable execution */
    declare function run();
}
/**Class representing a lock, for thread safety purposes */
declare class NJSLock
{
    /**
     *Acquire lock by thread calling this method,
     *If Lock already acquired by another thread, execution of calling thread should be blocked
     *until the other thread call the unlock method
     */
    declare function lock();
    /**
     *Try to acquire lock
     *If Lock already aquired by another thread, method returns false for calling thread
     *without blocking its execution
     *@return bool, return true if Lock acquire by calling thread, false otherwise
     */
    declare function tryLock(): boolean;
    /**Release Lock ownership by calling thread */
    declare function unlock();
}
/**Class representing context in which tasks get executed */
declare class NJSExecutionContext
{
    /**
     *Execute a given runnable
     *@param runnalbe, Runnable object
     */
    declare function execute(runnable: NJSRunnable);
    /**
     *Execute a given runnable with a delay
     *@param runnalbe, Runnable object
     *@param millis, 64 bits integer, delay in milli-seconds
     */
    declare function delay(runnable: NJSRunnable, millis: number);
}
/**Class representing a thread dispatcher */
declare class NJSThreadDispatcher
{
    /**
     *Get an execution context where tasks are executed sequentially
     *@param name, string, name of execution context to retrieve
     *@return ExecutionContext object
     */
    declare function getSerialExecutionContext(name: string): NJSExecutionContext;
    /**
     *Get an execution context where tasks are executed in parallel thanks to a thread pool
     *where a system of inter-thread communication was designed
     *@param name, string, name of execution context to retrieve
     *@return ExecutionContext object
     */
    declare function getThreadPoolExecutionContext(name: string): NJSExecutionContext;
    /**
     *Get main execution context (generally where tasks that should never get blocked are executed)
     *@return ExecutionContext object
     */
    declare function getMainExecutionContext(): NJSExecutionContext;
    /**
     *Get lock to handle multithreading
     *@return Lock object
     */
    declare function newLock(): NJSLock;
}
/**
 * Class representing a printer of errors, warnings, infos ... (at runtime).
 * Printed logs are stored in path set by PathResolver::resolveLogFilePath.
 */
declare class NJSLogPrinter
{
    /**
     * Print different encountered errors.
     * @param message, string
     */
    declare function printError(message: string);
    /**
     * Print useful information messages.
     * @param message, string
     */
    declare function printInfo(message: string);
    /**
     * Print debug messages.
     * @param message string
     */
    declare function printDebug(message: string);
    /**
     * Print warning messages.
     * @param message, string
     */
    declare function printWarning(message: string);
    /**
     * Print messages from APDU comand interpretation loop.
     * @param message, string
     */
    declare function printApdu(message: string);
    /**
     * Print critical errors causing a core dump or error from which recovery is impossible.
     * @param message, string
     */
    declare function printCriticalError(message: string);
    /**
     * Get context in which printer is executed (print).
     * @return ExecutionContext object
     */
    declare function getContext(): NJSExecutionContext;
}
/** Class to print logs to console. */
declare class NJSLogger
{
    /**
     * Print debug message to console.
     * @param tag, string
     * @param message, string
     */
    declare function d(tag: string, message: string);
    /**
     * Print information message to console.
     * @param tag, string
     * @param message, string
     */
    declare function i(tag: string, message: string);
    /**
     * Print error message to console.
     * @param tag, string
     * @param message, string
     */
    declare function e(tag: string, message: string);
    /**
     * Print warning message to console.
     * @param tag, string
     * @param message, string
     */
    declare function w(tag: string, message: string);
    /**
     * Print critical error message to console.
     * @param tag, string
     * @param message, string
     */
    declare function c(tag: string, message: string);
}
declare class NJSLedgerCore
{
    /**
     * Gets the version of the library as a human readable string.
     * @return The version of the library (e.g. '1.0.1')
     */
    static declare function getStringVersion(): string;
    /**
     * Get the integer version of the Library
     * @return The integer version of the library
     */
    static declare function getIntVersion(): number;
}
